ToDoList 说明文档
——368 吴兴明自科部后端方向（三最重要！！！！！！！）
一、项目架构
基于 Socket 的客户端 - 服务器模式任务管理系统，采用控制台操作，支持多客户端同时连接。核心功能为任务的增、查、改、删，可标记任务完成状态，整体模拟原神委托任务场景。
二、模块介绍
1. Client（客户端）
功能：与用户交互，接收用户指令并发送至服务器，展示服务器返回的响应结果。
设计：支持 add（添加任务）、list（查询任务）、modify（修改任务）、delete（删除任务）、exit（退出系统）、complete（标记任务完成）指令。
2. Server（服务器）
功能：持续监听客户端连接，每接收一个连接便开启独立线程处理，将用户的任务操作需求分发至对应功能模块。
设计：a 通过线程池实现多客户端同时使用；b 所有客户端共享一个任务列表，保证数据同步；c 具备指令识别能力，输入错误指令时会给出提示。
3. LinkedListTM（任务管理模块）
功能：负责任务的核心操作，包括添加、删除、修改、查询，采用 LinkedList 存储任务数据。
设计：① 利用 LinkedList 存储单个任务对象；② 任务 ID 自动递增，确保唯一性。
4. Task（任务实体）
功能：存储单个任务的信息（ID、任务内容、完成状态），支持完成状态切换操作。
设计：a 采用数据封装，通过 getter/setter 方法控制数据访问；b 内置状态切换和信息展示方法。
三、设计历程
（开始写程序时，从舍友口中得知程序员炒饭的故事，故特别注重对错误输入的处理）
首先规划创建两个核心类，分别用于任务描述和操作处理，即 Task（任务实体类）和 LinkedListTM（任务管理模块）。Task 类负责描述单个任务的具体信息，LinkedListTM 类通过各类指令操作 Task 对象。初期仅封装了任务的 ID 和 CONTENT 字段，先实现 add 方法，确保添加功能正常后再完善其他功能。
随后借助 AI 学习 Socket 相关知识，创建客户端和服务器模块，实现二者的基础通信。接着在服务器模块中添加对 add 指令的处理逻辑及客户端反馈机制，初期使用 ("add".equals (msg)) 判断指令，因无法识别 “add + 任务内容” 的格式，改为 msg.startsWith ("add")，试运行成功。
发现客户端缺乏指令格式提示，于是在客户端连接成功后，打印所有任务指令的格式及用途（当时规划了 add、list、delete、exit 指令），并在 LinkedListTM 中补充对应方法。实现 list 方法时，最初仅在服务器端显示任务，客户端无响应，后续通过 for 循环遍历所有任务并传入客户端，以 “------END------” 作为结束标志。设计 exit 方法时，原本直接用 break 退出，后来添加了自定义反馈信息并传入客户端。
完成初期开发后，发现遗漏了 modify 功能，补充完善后进行测试。测试中发现服务器端输入错误指令（如将 add 打成 ass）时，客户端会陷入无响应状态，需重新连接服务器。为此在 Client 模块添加 else 逻辑，当识别到非预设指令时，向客户端发送提醒，同时不影响后续操作。
受此启发，新增任务完成状态切换功能，最终完成系统开发。（最后开发阶段，舍友在玩原神，联想到原神委托与 todolist 功能相似，便将程序进行了原神化设计（偷笑））